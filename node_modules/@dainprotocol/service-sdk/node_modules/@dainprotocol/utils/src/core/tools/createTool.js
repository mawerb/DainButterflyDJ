"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTool = createTool;
const tslib_1 = require("tslib");
const zod_1 = require("zod");
function createTool(config) {
    // Validate the config
    if (!config.id || !config.name || !config.description) {
        throw new Error("Tool config is missing required fields");
    }
    // Ensure the handler respects the input and output schemas
    const wrappedHandler = (input, agentInfo, context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        var _a;
        let parsedInput;
        try {
            parsedInput = config.input.parse(input);
        }
        catch (error) {
            if (error instanceof zod_1.z.ZodError) {
                const missingParams = error.issues
                    .map((issue) => issue.path.join("."))
                    .join(", ");
                if (config.handleInputError) {
                    const errorResult = yield config.handleInputError(error, agentInfo, context);
                    // Expand process IDs in error handler result
                    let expandedProcesses;
                    if ((_a = errorResult.processes) === null || _a === void 0 ? void 0 : _a.length) {
                        expandedProcesses = yield Promise.all(errorResult.processes.map((process) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                            var _a;
                            if (typeof process === "string") {
                                const processInfo = yield ((_a = context === null || context === void 0 ? void 0 : context.app.processes) === null || _a === void 0 ? void 0 : _a.getProcess(process));
                                return {
                                    id: process,
                                    name: processInfo.name,
                                    description: processInfo.description,
                                    type: processInfo.type,
                                };
                            }
                            return process;
                        })));
                    }
                    return Object.assign(Object.assign({}, errorResult), { processes: expandedProcesses });
                }
                return {
                    text: `Error: Missing or invalid parameters for this tool call- '${missingParams}', Please ask the user to provide the missing values, or try again with the correct parameters.`,
                    data: {},
                    ui: {
                        type: "error",
                        message: `Please provide valid values for: ${missingParams}`,
                    },
                };
            }
            throw error;
        }
        const result = yield config.handler(parsedInput, agentInfo, {
            app: context === null || context === void 0 ? void 0 : context.app,
            extraData: context === null || context === void 0 ? void 0 : context.extraData,
        });
        // If processes is a string array, expand it
        let expandedProcesses;
        if (Array.isArray(result.processes)) {
            if (result.processes.length > 0 &&
                typeof result.processes[0] === "string") {
                expandedProcesses = yield Promise.all(result.processes.map((processId) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    var _a;
                    const processInfo = yield ((_a = context === null || context === void 0 ? void 0 : context.app.processes) === null || _a === void 0 ? void 0 : _a.getProcess(processId));
                    if (!processInfo)
                        throw new Error(`Process ${processId} not found`);
                    return {
                        id: processId,
                        name: processInfo.name,
                        description: processInfo.description,
                        type: processInfo.type,
                    };
                })));
            }
            else {
                expandedProcesses = result.processes;
            }
        }
        return {
            text: result.text,
            data: config.output.parse(result.data),
            ui: result.ui,
            pleasePay: result.pleasePay,
            processes: expandedProcesses,
        };
    });
    return Object.assign(Object.assign({}, config), { handler: wrappedHandler });
}
//# sourceMappingURL=createTool.js.map