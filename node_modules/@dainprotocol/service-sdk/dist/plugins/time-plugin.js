"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimePlugin = void 0;
const base_1 = require("./base");
/**
 * Example plugin that adds timing information to requests and responses
 */
class TimePlugin extends base_1.BaseDainPlugin {
    config;
    id = 'time-plugin';
    name = 'Time Plugin';
    version = '1.0.0';
    description = 'Adds timing information to requests and responses';
    type = 'both';
    constructor(config = {}) {
        super();
        this.config = config;
    }
    /**
     * Get plugin input data from a tool context with proper typing
     * Makes it easy for tools to access plugin data
     */
    getInputData(context) {
        return super.getInputData(context);
    }
    /**
     * Get plugin output data from a response with proper typing
     */
    getResponseData(response) {
        return super.getResponseData(response);
    }
    /**
     * Create a standardized response for this plugin with proper typing
     */
    createResponse(data) {
        return super.createResponse(data);
    }
    /**
     * Helper method to get and validate plugin data from a tool context
     * Returns a default value if plugin data is not found
     */
    getTimeDataFromContext(context) {
        const pluginData = this.getInputData(context);
        if (!pluginData) {
            return { clientTimestamp: Date.now() };
        }
        return pluginData;
    }
    /**
     * Helper method to create a response with current timestamps
     */
    createTimestampResponse(pluginInput) {
        const now = Date.now();
        if (!pluginInput) {
            return { clientTimestamp: 0, serviceTimestamp: now };
        }
        return {
            clientTimestamp: pluginInput.clientTimestamp,
            serviceTimestamp: now,
            timezone: pluginInput.timezone
        };
    }
    /**
     * Calculates the elapsed time between two timestamps
     */
    calculateElapsedTime(startTime, endTime = Date.now()) {
        return endTime - startTime;
    }
    /**
     * Formats a timestamp in ISO format
     */
    formatTimestamp(timestamp) {
        return new Date(timestamp).toISOString();
    }
    /**
     * Helper method to extract client timezone
     */
    getClientTimezone(context) {
        const pluginData = this.getInputData(context);
        return pluginData?.timezone;
    }
    async processInputClient(input) {
        // Add client timestamp to the request
        const clientTimestamp = Date.now();
        let pluginData = { clientTimestamp };
        // Add timezone if configured
        if (this.config.includeTimezone) {
            pluginData.timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
        }
        return pluginData;
    }
    async processInputService(input) {
        // No modifications needed for the service input
        return input;
    }
    async processOutputService(output) {
        // Get the plugin data from the request context
        // Try different paths to find the plugin input
        let pluginInput = output.context?.extraData?.plugins?.[this.id];
        // If not found in the usual path, try to find it elsewhere in the context
        if (!pluginInput && output.context?.request?.plugins) {
            pluginInput = output.context.request.plugins[this.id];
        }
        // Check in the nested extraData structure
        if (!pluginInput && output.context?.extraData?.extraData?.plugins) {
            pluginInput = output.context.extraData.extraData.plugins[this.id];
        }
        if (!pluginInput) {
            return {
                clientTimestamp: 0,
                serviceTimestamp: Date.now()
            };
        }
        // Add service timestamp to the response
        return {
            clientTimestamp: pluginInput.clientTimestamp,
            serviceTimestamp: Date.now(),
            timezone: pluginInput.timezone
        };
    }
    async processOutputClient(output) {
        // Get the plugin data from the response
        const pluginOutput = this.getResponseData(output);
        if (pluginOutput) {
            // Calculate roundtrip time
            const now = Date.now();
            const roundtripTime = now - pluginOutput.clientTimestamp;
            // Update the plugin data in the response
            output.plugins = output.plugins || {};
            // Make sure we preserve all fields from pluginOutput including timezone
            output.plugins[this.id] = {
                ...pluginOutput,
                roundtripTime
            };
        }
        return output;
    }
    /**
     * Practical utility for measuring performance of service operations.
     * This shows real-world usage of createResponse in a service operation.
     *
     * @param startTimestamp When the operation started (usually from client)
     * @param options Additional timing options
     * @returns A properly formatted time plugin response
     *
     * @example
     * // In a service operation:
     * async function processRequest(req) {
     *   const startTime = Date.now();
     *
     *   // Do some work...
     *   const result = await doExpensiveOperation();
     *
     *   // Measure timing and include in response
     *   const timing = timePlugin.createTimingResponse(startTime, {
     *     operationType: 'database-query',
     *     metadata: { rowsProcessed: 1500 }
     *   });
     *
     *   return {
     *     data: result,
     *     plugins: {
     *       'time-plugin': timing
     *     }
     *   };
     * }
     */
    createTimingResponse(startTimestamp, options = {}) {
        const now = Date.now();
        const elapsed = this.calculateElapsedTime(startTimestamp, now);
        // Create the base response with timing information
        const response = this.createResponse({
            clientTimestamp: startTimestamp,
            serviceTimestamp: now,
            roundtripTime: elapsed
        });
        // Add timezone if requested
        if (options.includeTimezone) {
            response.timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
        }
        // Log the timing data for monitoring/debugging
        console.log(`[TimePlugin] ${options.operationType || 'Operation'} completed in ${elapsed}ms`);
        if (options.metadata) {
            console.log(`[TimePlugin] Operation metadata:`, options.metadata);
        }
        return response;
    }
    /**
     * Creates a middleware function that automatically times tool executions
     * and adds timing information to the response.
     *
     * @param options Timing options for the middleware
     * @returns A middleware function that can wrap tool handlers
     *
     * @example
     * // Create a timed middleware
     * const timedMiddleware = timePlugin.createTimedMiddleware({
     *   includeTimezone: true
     * });
     *
     * // Create a tool with automatic timing
     * const myTool = createTool({
     *   id: "my-timed-tool",
     *   // ... other tool properties
     *   handler: timedMiddleware(async (params, agentInfo, context) => {
     *     // Your tool logic here
     *     return {
     *       text: "Result",
     *       data: { ... }
     *     };
     *   })
     * });
     */
    createTimedMiddleware(options = {}) {
        return (handler) => {
            return async (...args) => {
                // Extract the context from the arguments (usually the third argument)
                const context = args[2] || {};
                // Get the client timestamp if available in the plugin data
                const pluginData = this.getTimeDataFromContext(context);
                const startTime = pluginData.clientTimestamp;
                // Execute the wrapped handler function
                const result = await handler(...args);
                // Generate timing information
                const timingData = this.createTimingResponse(startTime, {
                    ...options,
                    operationType: options.operationType || 'tool-execution'
                });
                // Add the timing data to the result
                if (result && typeof result === 'object') {
                    result.plugins = result.plugins || {};
                    result.plugins[this.id] = timingData;
                }
                return result;
            };
        };
    }
}
exports.TimePlugin = TimePlugin;
//# sourceMappingURL=time-plugin.js.map