import { BaseDainPlugin } from './base';
interface TimePluginConfig {
    includeTimezone?: boolean;
}
interface TimePluginInput {
    clientTimestamp: number;
    timezone?: string;
}
interface TimePluginOutput {
    clientTimestamp: number;
    serviceTimestamp: number;
    roundtripTime?: number;
    timezone?: string;
}
/**
 * Performance measurement options for createTimingResponse
 */
export interface TimingOptions {
    /** Include timezone information */
    includeTimezone?: boolean;
    /** Add a custom operation type label */
    operationType?: string;
    /** Additional custom metadata */
    metadata?: Record<string, any>;
}
/**
 * Example plugin that adds timing information to requests and responses
 */
export declare class TimePlugin extends BaseDainPlugin<TimePluginConfig, TimePluginInput, TimePluginOutput> {
    config: TimePluginConfig;
    id: string;
    name: string;
    version: string;
    description: string;
    type: "both";
    constructor(config?: TimePluginConfig);
    /**
     * Get plugin input data from a tool context with proper typing
     * Makes it easy for tools to access plugin data
     */
    getInputData(context: any): TimePluginInput | undefined;
    /**
     * Get plugin output data from a response with proper typing
     */
    getResponseData(response: any): TimePluginOutput | undefined;
    /**
     * Create a standardized response for this plugin with proper typing
     */
    createResponse(data: Partial<TimePluginOutput>): TimePluginOutput;
    /**
     * Helper method to get and validate plugin data from a tool context
     * Returns a default value if plugin data is not found
     */
    getTimeDataFromContext(context: any): TimePluginInput;
    /**
     * Helper method to create a response with current timestamps
     */
    createTimestampResponse(pluginInput?: TimePluginInput): TimePluginOutput;
    /**
     * Calculates the elapsed time between two timestamps
     */
    calculateElapsedTime(startTime: number, endTime?: number): number;
    /**
     * Formats a timestamp in ISO format
     */
    formatTimestamp(timestamp: number): string;
    /**
     * Helper method to extract client timezone
     */
    getClientTimezone(context: any): string | undefined;
    processInputClient(input: any): Promise<TimePluginInput>;
    processInputService(input: any): Promise<any>;
    processOutputService(output: any): Promise<TimePluginOutput>;
    processOutputClient(output: any): Promise<any>;
    /**
     * Practical utility for measuring performance of service operations.
     * This shows real-world usage of createResponse in a service operation.
     *
     * @param startTimestamp When the operation started (usually from client)
     * @param options Additional timing options
     * @returns A properly formatted time plugin response
     *
     * @example
     * // In a service operation:
     * async function processRequest(req) {
     *   const startTime = Date.now();
     *
     *   // Do some work...
     *   const result = await doExpensiveOperation();
     *
     *   // Measure timing and include in response
     *   const timing = timePlugin.createTimingResponse(startTime, {
     *     operationType: 'database-query',
     *     metadata: { rowsProcessed: 1500 }
     *   });
     *
     *   return {
     *     data: result,
     *     plugins: {
     *       'time-plugin': timing
     *     }
     *   };
     * }
     */
    createTimingResponse(startTimestamp: number, options?: TimingOptions): TimePluginOutput;
    /**
     * Creates a middleware function that automatically times tool executions
     * and adds timing information to the response.
     *
     * @param options Timing options for the middleware
     * @returns A middleware function that can wrap tool handlers
     *
     * @example
     * // Create a timed middleware
     * const timedMiddleware = timePlugin.createTimedMiddleware({
     *   includeTimezone: true
     * });
     *
     * // Create a tool with automatic timing
     * const myTool = createTool({
     *   id: "my-timed-tool",
     *   // ... other tool properties
     *   handler: timedMiddleware(async (params, agentInfo, context) => {
     *     // Your tool logic here
     *     return {
     *       text: "Result",
     *       data: { ... }
     *     };
     *   })
     * });
     */
    createTimedMiddleware(options?: TimingOptions): (handler: Function) => (...args: any[]) => Promise<any>;
}
export {};
