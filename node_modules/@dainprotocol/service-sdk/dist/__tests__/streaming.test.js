"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const client_auth_1 = require("@/client/client-auth");
const client_1 = require("@/client/client");
const ed25519_1 = require("@noble/curves/ed25519");
const bs58_1 = tslib_1.__importDefault(require("bs58"));
const nodeService_1 = require("@/service/nodeService");
const core_1 = require("@/service/core");
const zod_1 = require("zod");
describe("DAIN Framework Streaming", () => {
    const privateKey = ed25519_1.ed25519.utils.randomPrivateKey();
    const publicKey = ed25519_1.ed25519.getPublicKey(privateKey);
    const address = bs58_1.default.encode(publicKey);
    const clientPrivateKey = ed25519_1.ed25519.utils.randomPrivateKey();
    const agentAuth = new client_auth_1.DainClientAuth({
        privateKeyBase58: bs58_1.default.encode(clientPrivateKey),
        agentId: "agent-12",
        orgId: "org-12",
    });
    // Initialize the connection to the DAIN service
    const dainConnection = new client_1.DainServiceConnection("http://localhost:4483", agentAuth);
    // Create a test tool with streaming updates
    const streamingTool = (0, core_1.createTool)({
        id: "streaming-test",
        name: "Streaming Test Tool",
        description: "Tool to test streaming functionality",
        input: zod_1.z.object({ message: zod_1.z.string() }),
        output: zod_1.z.object({ result: zod_1.z.string() }),
        handler: async ({ message }, agentInfo, context) => {
            console.log("Starting tool handler execution");
            // Send initial loading state
            if (context.updateUI) {
                console.log("Sending initial UI update");
                await context.updateUI({ ui: { type: "loading", message: "Starting..." } });
                console.log("Initial UI update sent");
            }
            // Add a delay - this is crucial for the test
            console.log("Starting first delay");
            await new Promise(resolve => setTimeout(resolve, 1000));
            console.log("First delay completed");
            // Create a process
            console.log("Creating process");
            const processId = await context.app.processes.createProcess(agentInfo, "one-time", "Streaming Test", `Testing streaming with: ${message}`);
            console.log("Process created with ID:", processId);
            // Notify about process creation
            if (context.addProcess) {
                console.log("Sending process update");
                await context.addProcess(processId);
                console.log("Process update sent");
            }
            // Add another delay
            console.log("Starting second delay");
            await new Promise(resolve => setTimeout(resolve, 1000));
            console.log("Second delay completed");
            // Send progress update
            if (context.updateUI) {
                console.log("Sending progress UI update");
                await context.updateUI({ ui: { type: "progress", message: "Processing..." } });
                console.log("Progress UI update sent");
            }
            // Final delay before result
            console.log("Starting final delay");
            await new Promise(resolve => setTimeout(resolve, 1000));
            console.log("Final delay completed");
            console.log("Returning final result");
            return {
                text: `Streaming test completed: ${message}`,
                data: { result: `completed-${message}` },
                ui: null,
            };
        },
    });
    const dainService = (0, nodeService_1.defineDAINService)({
        metadata: {
            title: "Streaming Test Service",
            description: "A DAIN service for testing streaming",
            version: "1.0.0",
            author: "Test Author",
            tags: ["streaming", "test"],
        },
        identity: {
            publicKey: bs58_1.default.encode(publicKey),
            agentId: "streaming-agent",
            orgId: "streaming-org",
            privateKey: bs58_1.default.encode(privateKey),
        },
        tools: [streamingTool],
    });
    let server;
    beforeAll(async () => {
        server = await dainService.startNode({ port: 4483 });
    });
    afterAll(async () => {
        await server.shutdown();
    });
    it("Sends SSE events immediately rather than buffering", async () => {
        const events = [];
        let lastTimestamp = Date.now();
        // Add a longer delay before starting to ensure clean timing
        await new Promise(resolve => setTimeout(resolve, 1000));
        console.log("=".repeat(80));
        console.log("STARTING STREAMING TEST", new Date().toISOString());
        console.log("=".repeat(80));
        const startTime = Date.now();
        lastTimestamp = startTime;
        console.log("Starting test at:", new Date(lastTimestamp).toISOString());
        const resultPromise = dainConnection.callTool("streaming-test", { message: "test message" }, {
            onUIUpdate: (update) => {
                const now = Date.now();
                const delay = now - lastTimestamp;
                const elapsedFromStart = now - startTime;
                console.log(`[${elapsedFromStart}ms] UI Update received:`, JSON.stringify(update.ui));
                console.log(`Delay since last event: ${delay}ms`);
                events.push({ type: 'ui', timestamp: now, delay, data: update.ui });
                lastTimestamp = now;
            },
            onProcess: (processId) => {
                const now = Date.now();
                const delay = now - lastTimestamp;
                const elapsedFromStart = now - startTime;
                console.log(`[${elapsedFromStart}ms] Process Update received:`, processId);
                console.log(`Delay since last event: ${delay}ms`);
                events.push({ type: 'process', timestamp: now, delay, data: processId });
                lastTimestamp = now;
            }
        });
        // Wait for result
        const result = await resultPromise;
        const now = Date.now();
        const finalDelay = now - lastTimestamp;
        const totalTime = now - startTime;
        console.log(`[${totalTime}ms] Final result received, delay: ${finalDelay}ms`);
        events.push({ type: 'result', timestamp: now, delay: finalDelay, data: result });
        // Log all events with timing info
        console.log("\nDETAILED EVENT TIMELINE:");
        console.log("=".repeat(80));
        events.forEach((event, i) => {
            const timeFromStart = event.timestamp - startTime;
            const eventDate = new Date(event.timestamp).toISOString();
            console.log(`Event ${i + 1}: ${event.type}`);
            console.log(`  Time: ${eventDate} (${timeFromStart}ms from start)`);
            console.log(`  Delay since previous: ${event.delay}ms`);
            if (event.data) {
                if (typeof event.data === 'object') {
                    console.log(`  Data: ${JSON.stringify(event.data)}`);
                }
                else {
                    console.log(`  Data: ${event.data}`);
                }
            }
            console.log("-".repeat(40));
        });
        // Verify we got all expected events
        expect(events).toHaveLength(4);
        // Check that events are received in the correct order
        expect(events[0].type).toBe('ui');
        expect(events[1].type).toBe('process');
        expect(events[2].type).toBe('ui');
        expect(events[3].type).toBe('result');
        // Adjust expectations for the timing
        // First UI update might take longer due to connection setup
        expect(events[0].timestamp - startTime).toBeLessThan(10000);
        // For the delays between events, we need to be more lenient
        // as network conditions can vary, but there should be SOME delay
        expect(events[1].delay).toBeGreaterThan(10);
        expect(events[2].delay).toBeGreaterThan(10);
        expect(events[3].delay).toBeGreaterThan(10);
        // Verify spacing between events - they should align roughly with
        // our 1000ms delays in the handler
        const timeBetweenFirstAndProcess = events[1].timestamp - events[0].timestamp;
        const timeBetweenProcessAndSecondUI = events[2].timestamp - events[1].timestamp;
        const timeBetweenSecondUIAndResult = events[3].timestamp - events[2].timestamp;
        console.log("\nTIMES BETWEEN EVENTS:");
        console.log(`First UI to Process: ${timeBetweenFirstAndProcess}ms`);
        console.log(`Process to Second UI: ${timeBetweenProcessAndSecondUI}ms`);
        console.log(`Second UI to Result: ${timeBetweenSecondUIAndResult}ms`);
        // These should each be at least 500ms given our 1000ms delays
        // but we allow for some variance in timing
        expect(timeBetweenFirstAndProcess).toBeGreaterThan(100);
        expect(timeBetweenProcessAndSecondUI).toBeGreaterThan(100);
        expect(timeBetweenSecondUIAndResult).toBeGreaterThan(100);
    });
    it("Maintains backwards compatibility with non-streaming clients", async () => {
        const result = await dainConnection.callTool("streaming-test", {
            message: "test message"
        });
        expect(result).toEqual({
            text: "Streaming test completed: test message",
            data: { result: "completed-test message" },
            ui: null,
        });
    });
    it("Can stream UI updates with callToolAndGetNewContext", async () => {
        const events = [];
        let lastTimestamp = Date.now();
        // Add a longer delay before starting to ensure clean timing
        await new Promise(resolve => setTimeout(resolve, 1000));
        console.log("=".repeat(80));
        console.log("STARTING CONTEXT STREAMING TEST", new Date().toISOString());
        console.log("=".repeat(80));
        const startTime = Date.now();
        lastTimestamp = startTime;
        console.log("Starting context test at:", new Date(lastTimestamp).toISOString());
        const resultPromise = dainConnection.callToolAndGetNewContext("streaming-test", { message: "test message" }, {
            onUIUpdate: (update) => {
                const now = Date.now();
                const delay = now - lastTimestamp;
                const elapsedFromStart = now - startTime;
                console.log(`[${elapsedFromStart}ms] Context UI Update received:`, JSON.stringify(update.ui));
                console.log(`Delay since last event: ${delay}ms`);
                events.push({ type: 'ui', timestamp: now, delay, data: update.ui });
                lastTimestamp = now;
            },
            onProcess: (processId) => {
                const now = Date.now();
                const delay = now - lastTimestamp;
                const elapsedFromStart = now - startTime;
                console.log(`[${elapsedFromStart}ms] Context Process Update received:`, processId);
                console.log(`Delay since last event: ${delay}ms`);
                events.push({ type: 'process', timestamp: now, delay, data: processId });
                lastTimestamp = now;
            }
        });
        // Wait for result
        const result = await resultPromise;
        const now = Date.now();
        const finalDelay = now - lastTimestamp;
        const totalTime = now - startTime;
        console.log(`[${totalTime}ms] Context final result received, delay: ${finalDelay}ms`);
        events.push({ type: 'result', timestamp: now, delay: finalDelay, data: result });
        // Log all events with timing info
        console.log("\nDETAILED CONTEXT EVENT TIMELINE:");
        console.log("=".repeat(80));
        events.forEach((event, i) => {
            const timeFromStart = event.timestamp - startTime;
            const eventDate = new Date(event.timestamp).toISOString();
            console.log(`Event ${i + 1}: ${event.type}`);
            console.log(`  Time: ${eventDate} (${timeFromStart}ms from start)`);
            console.log(`  Delay since previous: ${event.delay}ms`);
            if (event.data) {
                if (typeof event.data === 'object') {
                    console.log(`  Data: ${JSON.stringify(event.data)}`);
                }
                else {
                    console.log(`  Data: ${event.data}`);
                }
            }
            console.log("-".repeat(40));
        });
        // Verify we got at least the UI updates
        expect(events.length).toBeGreaterThan(1);
        // Check if we have UI updates
        const uiEvents = events.filter(e => e.type === 'ui');
        expect(uiEvents.length).toBeGreaterThan(0);
        // Check the first UI event
        if (uiEvents.length >= 1) {
            expect(uiEvents[0].data).toEqual({ type: "loading", message: "Starting..." });
        }
        // Check the second UI event if it exists
        if (uiEvents.length >= 2) {
            expect(uiEvents[1].data).toEqual({ type: "progress", message: "Processing..." });
        }
        // Verify final result
        const resultEvent = events.find(e => e.type === 'result');
        expect(resultEvent).toBeDefined();
        expect(resultEvent.data.toolResult).toEqual({
            text: "Streaming test completed: test message",
            data: { result: "completed-test message" },
            ui: null,
        });
        // If we have more than one event, check that there are delays between them
        if (events.length > 1) {
            for (let i = 1; i < events.length; i++) {
                expect(events[i].delay).toBeGreaterThan(10);
            }
            // Calculate time between events
            if (events.length >= 3) {
                console.log("\nTIMES BETWEEN CONTEXT EVENTS:");
                for (let i = 1; i < events.length; i++) {
                    const timeFromPrevious = events[i].timestamp - events[i - 1].timestamp;
                    console.log(`From ${events[i - 1].type} to ${events[i].type}: ${timeFromPrevious}ms`);
                }
            }
        }
    });
});
//# sourceMappingURL=streaming.test.js.map