"use strict";
// File: src/__tests__/plugin.test.ts
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const client_auth_1 = require("@/client/client-auth");
const client_1 = require("@/client/client");
const ed25519_1 = require("@noble/curves/ed25519");
const bs58_1 = tslib_1.__importDefault(require("bs58"));
const nodeService_1 = require("@/service/nodeService");
const core_1 = require("@/service/core");
const zod_1 = require("zod");
const time_plugin_1 = require("@/plugins/time-plugin");
describe("DAIN Framework Plugin System", () => {
    const privateKey = ed25519_1.ed25519.utils.randomPrivateKey();
    const publicKey = ed25519_1.ed25519.getPublicKey(privateKey);
    const address = bs58_1.default.encode(publicKey);
    const clientPrivateKey = ed25519_1.ed25519.utils.randomPrivateKey();
    const agentAuth = new client_auth_1.DainClientAuth({
        privateKeyBase58: bs58_1.default.encode(clientPrivateKey),
        agentId: "agent-12",
        orgId: "org-12",
    });
    // Create a TimePlugin instance
    const timePlugin = new time_plugin_1.TimePlugin({ includeTimezone: true });
    // Initialize the connection to the DAIN service with the time plugin
    const dainConnection = new client_1.DainServiceConnection("http://localhost:4484", agentAuth, {
        plugins: [timePlugin]
    });
    // Create a test tool
    const echoTool = (0, core_1.createTool)({
        id: "echo",
        name: "Echo Tool",
        description: "Echoes back the input with plugin data",
        input: zod_1.z.object({ message: zod_1.z.string() }),
        output: zod_1.z.object({ message: zod_1.z.string(), plugins: zod_1.z.any() }),
        handler: async ({ message }, agentInfo, context) => {
            console.log("Context:", JSON.stringify(context, null, 2));
            // Use the TimePlugin helper to get plugin data from context
            const timeData = timePlugin.getTimeDataFromContext(context);
            const clientTimezone = timePlugin.getClientTimezone(context);
            console.log(`Tool handling: received client timestamp ${timeData.clientTimestamp}`);
            if (clientTimezone) {
                console.log(`Client timezone: ${clientTimezone}`);
            }
            return {
                text: `Echoed: ${message}`,
                data: {
                    message,
                    plugins: context.extraData?.plugins || {}
                },
                ui: null,
            };
        },
    });
    // Initialize the DAIN service with the plugin
    const dainService = (0, nodeService_1.defineDAINService)({
        metadata: {
            title: "Plugin Test Service",
            description: "A DAIN service for testing plugins",
            version: "1.0.0",
            author: "Test Author",
            tags: ["plugin", "test"],
        },
        identity: {
            publicKey: bs58_1.default.encode(publicKey),
            agentId: "plugin-agent",
            orgId: "plugin-org",
            privateKey: bs58_1.default.encode(privateKey),
        },
        tools: [echoTool],
        plugins: [timePlugin]
    });
    let server;
    beforeAll(async () => {
        server = await dainService.startNode({ port: 4484 });
        await new Promise(resolve => setTimeout(resolve, 500)); // Give server time to start
    });
    afterAll(async () => {
        await server.shutdown();
    });
    it("should process plugin data in requests and responses", async () => {
        // Call the echo tool with a message
        const result = await dainConnection.callTool("echo", { message: "Hello, plugins!" });
        console.log("Tool result:", JSON.stringify(result, null, 2));
        // Verify that the message was echoed correctly
        expect(result.data.message).toBe("Hello, plugins!");
        // Verify that the time plugin data is in the response
        expect(result.plugins).toBeDefined();
        expect(result.plugins["time-plugin"]).toBeDefined();
        // Use the TimePlugin helper to get typed response data
        const timeData = timePlugin.getResponseData(result);
        expect(timeData).toBeDefined();
        // Check the time plugin data
        expect(timeData.clientTimestamp).toBeDefined();
        expect(timeData.serviceTimestamp).toBeDefined();
        expect(timeData.roundtripTime).toBeDefined();
        expect(timeData.timezone).toBeDefined();
        // The service timestamp should be later than the client timestamp
        expect(timeData.serviceTimestamp).toBeGreaterThanOrEqual(timeData.clientTimestamp);
        // The roundtrip time should be non-negative
        expect(timeData.roundtripTime).toBeGreaterThanOrEqual(0);
        // The timezone should be a non-empty string
        expect(typeof timeData.timezone).toBe("string");
        expect(timeData.timezone.length).toBeGreaterThan(0);
        console.log("Time plugin data:", timeData);
        // Use TimePlugin's helper methods for displaying timestamps nicely
        console.log(`Request started at: ${timePlugin.formatTimestamp(timeData.clientTimestamp)}`);
        console.log(`Response created at: ${timePlugin.formatTimestamp(timeData.serviceTimestamp)}`);
        console.log(`Roundtrip time: ${timeData.roundtripTime}ms`);
        console.log(`Client timezone: ${timeData.timezone}`);
        // Demonstrate the elapsed time calculation helper
        const processingTime = timePlugin.calculateElapsedTime(timeData.clientTimestamp, timeData.serviceTimestamp);
        console.log(`Service processing time: ${processingTime}ms`);
    });
    it("should work with streaming responses", async () => {
        const events = [];
        // Call the echo tool with streaming enabled
        const result = await dainConnection.callTool("echo", { message: "Hello with streaming!" }, {
            onUIUpdate: (update) => {
                events.push({ type: 'ui', timestamp: Date.now(), data: update });
            }
        });
        // Add the final result to the events
        events.push({ type: 'result', timestamp: Date.now(), data: result });
        // Verify the result has plugin data
        expect(result.plugins).toBeDefined();
        expect(result.plugins["time-plugin"]).toBeDefined();
        // Get typed plugin data using helper
        const timeData = timePlugin.getResponseData(result);
        expect(timeData).toBeDefined();
        expect(timeData.roundtripTime).toBeDefined();
        console.log("Streaming result time data:", timeData);
        console.log(`Streaming roundtrip time: ${timeData.roundtripTime}ms`);
    });
    it("should work when calling a tool and getting context", async () => {
        // Call the echo tool and get context
        const result = await dainConnection.callToolAndGetNewContext("echo", {
            message: "Hello with context!"
        });
        // Verify the result has plugin data
        expect(result.plugins).toBeDefined();
        expect(result.plugins["time-plugin"]).toBeDefined();
        // Get typed plugin data using helper
        const timeData = timePlugin.getResponseData(result);
        expect(timeData).toBeDefined();
        expect(timeData.roundtripTime).toBeDefined();
        // Verify the tool result
        expect(result.toolResult.data.message).toBe("Hello with context!");
        console.log("Context result time data:", timeData);
        console.log(`Context roundtrip time: ${timeData.roundtripTime}ms`);
    });
    it("should use helper methods to create custom time responses", async () => {
        // Create a mock context with plugin data
        const mockContext = {
            extraData: {
                plugins: {
                    "time-plugin": {
                        clientTimestamp: Date.now() - 100, // 100ms ago
                        timezone: "Europe/London"
                    }
                }
            }
        };
        // Use helper to extract the plugin data
        const inputData = timePlugin.getTimeDataFromContext(mockContext);
        expect(inputData.clientTimestamp).toBeDefined();
        expect(inputData.timezone).toBe("Europe/London");
        // Use helper to create a response
        const response = timePlugin.createTimestampResponse(inputData);
        expect(response.clientTimestamp).toBe(inputData.clientTimestamp);
        expect(response.serviceTimestamp).toBeDefined();
        expect(response.timezone).toBe("Europe/London");
        // Calculate processing time
        const processingTime = timePlugin.calculateElapsedTime(response.clientTimestamp, response.serviceTimestamp);
        console.log(`Mock request: client timestamp is ${timePlugin.formatTimestamp(inputData.clientTimestamp)}`);
        console.log(`Mock response: service timestamp is ${timePlugin.formatTimestamp(response.serviceTimestamp)}`);
        console.log(`Mock processing time: ${processingTime}ms`);
    });
    it("should demonstrate the createResponse method for plugin responses", async () => {
        console.log("=== DEMONSTRATING createResponse METHOD ===");
        // Scenario 1: Create a minimal response with just required fields
        const minimalResponse = timePlugin.createResponse({
            clientTimestamp: 1742160000000,
            serviceTimestamp: 1742160000050
        });
        console.log("Minimal Response:", minimalResponse);
        expect(minimalResponse.clientTimestamp).toBe(1742160000000);
        expect(minimalResponse.serviceTimestamp).toBe(1742160000050);
        expect(minimalResponse.timezone).toBeUndefined();
        expect(minimalResponse.roundtripTime).toBeUndefined();
        // Scenario 2: Create a complete response with all fields
        const completeResponse = timePlugin.createResponse({
            clientTimestamp: 1742160000100,
            serviceTimestamp: 1742160000150,
            timezone: "America/Chicago",
            roundtripTime: 75
        });
        console.log("Complete Response:", completeResponse);
        expect(completeResponse.clientTimestamp).toBe(1742160000100);
        expect(completeResponse.serviceTimestamp).toBe(1742160000150);
        expect(completeResponse.timezone).toBe("America/Chicago");
        expect(completeResponse.roundtripTime).toBe(75);
        // Scenario 3: Using createResponse to transform or annotate data
        const rawData = {
            clientTimestamp: Date.now() - 200,
            serviceTimestamp: Date.now() - 100
        };
        // Add a timezone and calculate a roundtrip time
        const enhancedResponse = timePlugin.createResponse({
            ...rawData,
            timezone: "UTC",
            roundtripTime: rawData.serviceTimestamp - rawData.clientTimestamp
        });
        console.log("Enhanced Response:", enhancedResponse);
        expect(enhancedResponse.timezone).toBe("UTC");
        expect(enhancedResponse.roundtripTime).toBe(100);
        // Scenario 4: Practical example - modifying an existing plugin response
        const existingResponse = {
            clientTimestamp: 1742160000200,
            serviceTimestamp: 1742160000300,
            timezone: "Europe/Berlin"
        };
        // Add roundtrip time to an existing response
        const updatedResponse = timePlugin.createResponse({
            ...existingResponse,
            roundtripTime: 120 // Custom roundtrip calculation
        });
        console.log("Updated Response:", updatedResponse);
        expect(updatedResponse).toEqual({
            clientTimestamp: 1742160000200,
            serviceTimestamp: 1742160000300,
            timezone: "Europe/Berlin",
            roundtripTime: 120
        });
        // Scenario 5: Integration with other helper methods
        const now = Date.now();
        const sampleInput = { clientTimestamp: now - 150, timezone: "Asia/Tokyo" };
        // Create a response using multiple helper methods together
        const integratedResponse = timePlugin.createResponse({
            clientTimestamp: sampleInput.clientTimestamp,
            serviceTimestamp: now,
            timezone: sampleInput.timezone,
            roundtripTime: timePlugin.calculateElapsedTime(sampleInput.clientTimestamp, now)
        });
        console.log("Integrated Response:", integratedResponse);
        console.log(`From ${timePlugin.formatTimestamp(integratedResponse.clientTimestamp)}`);
        console.log(`To ${timePlugin.formatTimestamp(integratedResponse.serviceTimestamp)}`);
        console.log(`Elapsed: ${integratedResponse.roundtripTime}ms in ${integratedResponse.timezone}`);
        expect(integratedResponse.roundtripTime).toBe(150);
        expect(integratedResponse.timezone).toBe("Asia/Tokyo");
    });
    it("should demonstrate practical usage of createTimingResponse for real-world scenarios", async () => {
        console.log("\n=== DEMONSTRATING PRACTICAL USAGE OF TIME PLUGIN ===\n");
        // Example 1: Measuring execution time of an expensive operation
        const simulateExpensiveOperation = async (duration) => {
            return new Promise(resolve => setTimeout(() => resolve(`Operation completed`), duration));
        };
        console.log("Example 1: Measuring database query performance");
        console.log("----------------------------------------------");
        const dbQueryStart = Date.now();
        // Simulate a database query that takes 50ms
        await simulateExpensiveOperation(50);
        // Generate timing information for this operation
        const dbQueryTiming = timePlugin.createTimingResponse(dbQueryStart, {
            operationType: "database-query",
            includeTimezone: true,
            metadata: {
                table: "users",
                rowsReturned: 250,
                indexUsed: "user_id_idx"
            }
        });
        console.log(`Database query timing: ${JSON.stringify(dbQueryTiming, null, 2)}`);
        console.log(`Query started at: ${timePlugin.formatTimestamp(dbQueryTiming.clientTimestamp)}`);
        console.log(`Query completed at: ${timePlugin.formatTimestamp(dbQueryTiming.serviceTimestamp)}`);
        console.log(`Query took approximately: ${dbQueryTiming.roundtripTime}ms`);
        expect(dbQueryTiming.roundtripTime).toBeGreaterThanOrEqual(50);
        expect(dbQueryTiming.timezone).toBeDefined();
        // Example 2: API request/response cycle with multiple operations
        console.log("\nExample 2: Full API request cycle with multiple operations");
        console.log("------------------------------------------------------");
        // Simulate a complete API request handler with multiple operations
        const handleApiRequest = async (requestData) => {
            // 1. Record request start time
            const requestStart = Date.now();
            // 2. Validate request (10ms)
            await simulateExpensiveOperation(10);
            const validationTiming = timePlugin.createTimingResponse(requestStart, {
                operationType: "request-validation"
            });
            // 3. Process data (30ms)
            const processingStart = Date.now();
            await simulateExpensiveOperation(30);
            const processingTiming = timePlugin.createTimingResponse(processingStart, {
                operationType: "data-processing"
            });
            // 4. Generate response with detailed timing information
            return {
                data: { result: "Success", id: requestData.id },
                timing: {
                    total: timePlugin.createTimingResponse(requestStart),
                    validation: validationTiming,
                    processing: processingTiming
                }
            };
        };
        // Simulate an API request
        const apiResponse = await handleApiRequest({ id: 12345, action: "getData" });
        console.log("API Response:", JSON.stringify(apiResponse, null, 2));
        console.log(`Total request time: ${apiResponse.timing.total.roundtripTime}ms`);
        console.log(`- Validation time: ${apiResponse.timing.validation.roundtripTime}ms`);
        console.log(`- Processing time: ${apiResponse.timing.processing.roundtripTime}ms`);
        expect(apiResponse.timing.total.roundtripTime).toBeGreaterThanOrEqual(40);
        expect(apiResponse.timing.validation.roundtripTime).toBeGreaterThanOrEqual(10);
        expect(apiResponse.timing.processing.roundtripTime).toBeGreaterThanOrEqual(30);
        // Show how this would be integrated into a real DAIN plugin response
        const pluginResponse = {
            data: apiResponse.data,
            plugins: {
                "time-plugin": timePlugin.createTimingResponse(apiResponse.timing.total.clientTimestamp, {
                    includeTimezone: true
                })
            }
        };
        console.log("\nFinal plugin response:");
        console.log(JSON.stringify(pluginResponse, null, 2));
        expect(pluginResponse.plugins["time-plugin"].roundtripTime).toBeGreaterThanOrEqual(40);
        expect(pluginResponse.plugins["time-plugin"].timezone).toBeDefined();
    });
});
//# sourceMappingURL=plugin.test.js.map